;;; an ASCII implementation of Conway's Game of Life

fn random_x() -> x {
    ' ' -> x;
    if(random(1) = 1) {
        'X' -> x;
    }
}

fn initialize(size) -> representation {

    "" -> str;
    0 -> i;
    while(i < size) {
        random_x() -> $str;
        1 + i -> i;
    }
    ;;; initialize the representation array
    str -> $representation;

    1 -> outer;
    while (outer < size) {

        0 -> inner;
        "" -> str;
        while(inner < size) {
            random_x() -> $str;
            inner + 1 -> inner;
        }
        str -> $representation;
        outer + 1 -> outer;
    }
}

fn print(representation) {
    for str in representation {
        for c in str {
            pr "" + c; pr " ";
        }
        prn "";
    }
}

;;; takes the current cell value and all neighbours
;;; and generates what the outcome should be.
fn transition(current, neighbours) -> result {
    0 -> alive;
    ' ' -> result;
    for n in neighbours {
        if(n = 'X') {
            1 + alive -> alive;
        }
    }
    if((current = 'X') && alive < 2) {
        ' ' -> result;
    } elseif((current = 'X') && ((alive = 2) || (alive = 3))) {
        'X' -> result;
    } elseif((current = 'X') && alive > 3) {
        ' ' -> result;
    } elseif((current = ' ') && alive = 3) {
        'X' -> result;
    }
}

fn update(representation, size) -> representation {
    0 -> r;
    "" -> row;
    representation -> new_rep;
    for row in representation {
        0 -> c;
        "" -> new_str;
        ' ' -> column;

        ;;; the 'next' or below row
        "" -> below_row;
        if(r >= size - 1) {
            representation:0 -> below_row;
        } else {
            representation:(r + 1) -> below_row;
        }

        ;;; the 'preceding' or above row
        "" -> above_row;
        if(r = 0) {
            representation:(size - 1) -> above_row;
        } else {
            representation:(r - 1) -> above_row;
        }

        for column in row {
            "" -> neighbours;
            ;;; cell plus one
            if(c < size - 1) {
                row:(c + 1) -> $neighbours;
            } else {
                row:0 -> $neighbours;
            }
            ;;; cell minus one
            if(c > 0) {
                row:(c - 1) -> $neighbours;
            } else {
                row:(size - 1) -> $neighbours;
            }
            ;;; below
            below_row:c -> $neighbours;

            ;;; above
            above_row:c -> $neighbours;

            ;;; below-right
            if(c < size - 1) {
                below_row:(c + 1) -> $neighbours;
            } else {
                below_row:0 -> $neighbours;
            }

            ;;; below-left
            if(c > 0) {
                below_row:(c - 1) -> $neighbours;
            } else {
                below_row:(size - 1) -> $neighbours;
            }

            ;;; above-right
            if(c < size - 1) {
                above_row:(c + 1) -> $neighbours;
            } else {
                above_row:0 -> $neighbours;
            }

            ;;; above-left
            if(c > 0) {
                above_row:(c - 1) -> $neighbours;
            } else {
                above_row:(size - 1) -> $neighbours;
            }

            ;;; figure out new state
            transition(row:c, neighbours) -> $new_str;
            c + 1 -> c;
        }
        new_str -> new_rep:r;
        r + 1 -> r;
    }
    new_rep -> representation;
}

start {
    arg(0) -> size;
    initialize(size) -> representation;
    print(representation);
    0 -> it;
    while(true) {
        update(representation, size) -> representation;
        ansi_up size;
        print(representation);
        it + 1 -> it;
    }
}