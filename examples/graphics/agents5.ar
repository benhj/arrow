;;; Expanding the simulation further; collision detection

;;; Global Pod Declarations (ONLY these are allowed globally)
pod foodItem(x, y, active, r, g, b);
;;; REVISED: Pod definition for the Agent WITH NN weights AND fitness_score as members
;;; This assumes the language *does* support 2D arrays as pod members.
pod agentPod(x, y, radius, speed, momentum_x, momentum_y, r, g, b, heading,
             antenna_length, antenna_angle_offset, antenna_tip_radius, antenna_r, antenna_g, antenna_b,
             flash_timer, flash_duration, flash_r, flash_g, flash_b,
             weights_input_hidden, ;;; NEW: 2D array for input to hidden layer weights
             weights_hidden_output, ;;; NEW: 2D array for hidden to output layer weights
             fitness_score,
             id, ;;; NEW: Add a unique ID for each agent to prevent self-collision checks
             tail_segment_count, ;;; NEW: Number of segments in the tail
             tail_segment_scale_factor, ;;; NEW: Factor by which each segment's radius decreases
             tail_segment_spacing, ;;; NEW: Spacing between tail segments for initial placement
             tail_positions); ;;; NEW: Array to store (x, y) positions of tail segments



fn checkOccupied(food_item, agents_array) -> occupied {

    false -> occupied;
    for agent in agents_array {
        agent:x - food_item:x -> dx;
        agent:y - food_item:y -> dy;
        (dx * dx) + (dy * dy) -> dist_sq;
        sqrt(dist_sq) -> distance;
        if(distance < 40) {
            true -> occupied;
            break;
        }
    }
}

fn checkFoodOverlap(index, food_item, all_food_array) -> occupied {

    false -> occupied;
    0 -> i;
    for item in all_food_array {
        i + 1 -> i;
        if i - 1 = index { continue; }
        item:x - food_item:x -> dx;
        item:y - food_item:y -> dy;
        (dx * dx) + (dy * dy) -> dist_sq;
        sqrt(dist_sq) -> distance;
        if(distance < 40) {
            true -> occupied;
            break;
        }
    }
}

;;; --- Neural Network Helper Functions ---

;;; Function to initialize a 2D array (matrix) with random values
fn init2DArray(rows, cols) -> new_2d_array {
    [] -> new_2d_array;
    0 -> i;
    repeat rows times {
        [] -> inner_array;
        0 -> j;
        repeat cols times {
            random(1.0) * 2 - 1 -> rand_val;
            ;;; Initialize weights between -1.0 and 1.0
            rand_val -> $inner_array;
            j + 1 -> j;
        }
        inner_array -> $new_2d_array;
        i + 1 -> i;
    }
}

;;; Sigmoid activation function
fn sigmoid(x) -> result {
    1.0 + exp(-x) -> denominator;
    1.0 / denominator -> result;
}

;;; Calculates the output of a single layer in the neural network
;;; input_array: activations from the previous layer
;;; weights_matrix: weights connecting input_array to this layer
fn calculate_layer_output(input_array, weights_matrix) -> output_activations {
    [] -> output_activations;
    length(weights_matrix:0) -> num_neurons_in_layer; ;;; Number of neurons in the current layer (cols of weights_matrix)

    0 -> j;
    repeat num_neurons_in_layer times {
        0.0 -> weighted_sum;

        ;;; Add bias input (assumed to be the last row of weights_matrix)
        weights_matrix:(length(input_array)) -> inner;
        inner:j -> bias_weight;
        weighted_sum + bias_weight -> weighted_sum;

        ;;; Sum inputs * weights
        0 -> i;
        repeat length(input_array) times {
            input_array:i -> input_val;
            weights_matrix:i -> inner;
            inner:j -> weight_val;
            weighted_sum + (input_val * weight_val) -> weighted_sum;
            i + 1 -> i;
        }
        sigmoid(weighted_sum) -> neuron_output;
        neuron_output -> $output_activations;
        j + 1 -> j;
    }
}

;;; Function to get a single antenna's reading (RGB, bearing, distance to closest food)
fn get_antenna_reading(agent_x, agent_y, current_antenna_heading, food_array, food_count, food_radius, pi_val, canvas_width, canvas_height) -> antenna_output {
    999999.0 -> closest_dist_sq; ;;; Start with a very large distance
    0 -> found_food;
    0 -> closest_food_r;
    0 -> closest_food_g;
    0 -> closest_food_b;
    0.0 -> closest_food_bearing; ;;; Bearing relative to antenna heading

    0 -> i;
    repeat food_count times {
        food_array:i -> current_food_item;
        current_food_item:active -> is_active;
        if (is_active = 1) {
            current_food_item:x -> food_x;
            current_food_item:y -> food_y;

            agent_x - food_x -> dx;
            agent_y - food_y -> dy;
            (dx * dx) + (dy * dy) -> dist_sq;

            if (dist_sq < closest_dist_sq) {
                dist_sq -> closest_dist_sq;
                1 -> found_food;

                ;;; Get RGB values for the closest food item from its pod members
                current_food_item:r / 255 -> closest_food_r;
                current_food_item:g / 255 -> closest_food_g;
                current_food_item:b / 255 -> closest_food_b;

                ;;; Calculate angle from agent to food relative to world X axis
                atan2(food_y - agent_y, food_x - agent_x) -> angle_to_food;
                ;;; Calculate bearing relative to antenna's heading
                angle_to_food - current_antenna_heading -> relative_bearing;
                ;;; Normalize bearing to [-pi, pi]

                while (relative_bearing <= -pi_val) { relative_bearing + (2 * pi_val) -> relative_bearing; }
                while (relative_bearing > pi_val) { relative_bearing - (2 * pi_val) -> relative_bearing; }
                relative_bearing -> closest_food_bearing;
            }
        }
        i + 1 -> i;
    }

    sqrt(closest_dist_sq) -> closest_dist;

    ;;; If no food was found, return default "no detection" values (e.g., black/zero)
    if (found_food = 0) {
        0.0 -> closest_food_bearing;
        0 -> closest_food_r;
        0 -> closest_food_g;
        0 -> closest_food_b;
    }
    closest_food_bearing / pi_val -> normalizedBearing;
    [^closest_food_r ^closest_food_g ^closest_food_b ^normalizedBearing] -> antenna_output;
}

fn normalize_angle(angle, pi_val) -> normalized_angle {
    (2 * pi_val) -> two_pi;
    ;;; Step 1: Shift the angle into a positive range [0, 2*pi) for modulo
    ;;; Add pi_val to shift from (-pi, pi] to (0, 2*pi].
    ;;; Then add two_pi to ensure it's definitely positive before modulo,
    ;;; as some modulo implementations can return negative for negative inputs.
    (angle + pi_val + two_pi) -> temp_angle;
    (temp_angle % two_pi + two_pi) % two_pi -> wrapped_angle; ;;; This ensures positive result for remainder

    ;;; Step 3: Shift back to the desired (-pi, pi] range
    (wrapped_angle - pi_val) -> normalized_angle;
    normalized_angle -> normalized_angle; ;;; Return the final normalized angle
}


;;; Function to get an antenna reading for other agents (specifically infected ones)
;;; Returns a tuple/array: [detected_r, detected_g, detected_b, relative_bearing, distance]
fn get_agent_antenna_reading(current_agent_x, current_agent_y, current_antenna_heading,
                             antenna_length_val, antenna_tip_radius_val, antenna_angle_offset_val,
                             all_agents_array, num_agents_val, current_agent_id, ;;; NEW inputs for agent sensing
                             pi_val, canvas_width, canvas_height) -> antenna_output_for_agents {
    ;;; Initialize default 'no detection' values
    0 -> detected_r;
    0 -> detected_g;
    0 -> detected_b;
    0.0 -> relative_bearing;
    -1.0 -> distance;           ;;; Use -1 for no detection
    999999.0 -> closest_dist_sq; ;;; Start with a very large distance

    antenna_length_val -> current_antenna_x_offset;
    antenna_length_val -> current_antenna_y_offset;

    ;;; Calculate the antenna tip's coordinates
    cos(current_antenna_heading) -> cos_val;
    sin(current_antenna_heading) -> sin_val;
    (current_agent_x + (cos_val * current_antenna_x_offset)) -> antenna_tip_x;
    (current_agent_y + (sin_val * current_antenna_y_offset)) -> antenna_tip_y;

    antenna_tip_radius_val -> antenna_detection_radius;

    0 -> i;
    repeat num_agents_val times {
        all_agents_array:i -> other_agent_pod;

        ;;; Skip checking against itself
        if (other_agent_pod:id /= current_agent_id) { ;;; Assuming you add an 'id' to agentPod
            ;;; Check if the other agent is infected (flashing red)
            other_agent_pod:flash_timer -> other_flash_timer;
            other_agent_pod:flash_r -> other_flash_r;
            other_agent_pod:flash_g -> other_flash_g;
            other_agent_pod:flash_b -> other_flash_b;

            if (other_flash_timer > 0 && other_flash_r = 255 && other_flash_g = 0 && other_flash_b = 0) {
                ;;; Calculate distance from antenna tip to other agent
                antenna_tip_x - other_agent_pod:x -> dx;
                antenna_tip_y - other_agent_pod:y -> dy;
                (dx * dx) + (dy * dy) -> dist_sq;

                other_agent_pod:radius + antenna_detection_radius -> combined_radii;
                combined_radii * combined_radii -> combined_radii_sq;

                if (dist_sq <= closest_dist_sq) {


                    ;;; Calculate distance and relative bearing to the detected infected agent
                    sqrt(dist_sq) -> current_distance;
                    atan2(dy, dx) -> angle_to_target; ;;; Angle from antenna tip to target
                    (angle_to_target - current_antenna_heading) -> relative_bearing;
                    ;;;prn current_relative_bearing;

                    ;;; Return the detected agent's flash color, relative bearing, and distance
                    other_flash_r -> detected_r;
                    other_flash_g -> detected_g;
                    other_flash_b -> detected_b;

                    while (relative_bearing <= -pi_val) { relative_bearing + (2 * pi_val) -> relative_bearing; }
                    while (relative_bearing > pi_val) { relative_bearing - (2 * pi_val) -> relative_bearing; }

                    current_distance -> distance;
                    ;;; Break loop as we've found the closest/first infected agent in range
                    break;
                }
            }
        }
        i + 1 -> i;
    }
    ;;; Return the collected data (even if it's the default 'no detection' values)
    detected_r / 255.0 -> detected_r;
    detected_g / 255.0 -> detected_g;
    detected_b / 255.0 -> detected_b;
    if (distance > 10) {
        0 -> detected_r;
        0 -> detected_g;
        0 -> detected_b;
        0 -> relative_bearing;
    }
    [^detected_r ^detected_g ^detected_b ^relative_bearing] -> antenna_output_for_agents;
}


;;; UPDATED: The agent's neural network "think" function now accesses weights directly from the pod
fn agent_think(all_agents_array, current_agent_pod, food_array, food_count, food_radius, canvas_width, canvas_height, pi_val) -> nn_outputs {
    current_agent_pod:x -> agent_x;
    current_agent_pod:y -> agent_y;
    current_agent_pod:heading -> agent_heading;
    current_agent_pod:antenna_angle_offset -> antenna_offset;

    ;;; Get left antenna readings
    agent_heading - antenna_offset -> left_antenna_heading;
    get_antenna_reading(agent_x, agent_y, left_antenna_heading, food_array, food_count, food_radius, pi_val, canvas_width, canvas_height) -> left_food_inputs;

    ;;; Get right antenna readings
    agent_heading + antenna_offset -> right_antenna_heading;
    get_antenna_reading(agent_x, agent_y, right_antenna_heading, food_array, food_count, food_radius, pi_val, canvas_width, canvas_height) -> right_food_inputs;


    ;;; NEW: Get readings for other agents (infected ones)
    get_agent_antenna_reading(agent_x, agent_y, left_antenna_heading,
                              current_agent_pod:antenna_length, current_agent_pod:antenna_tip_radius,
                              current_agent_pod:antenna_angle_offset,
                              all_agents_array, length(all_agents_array), current_agent_pod:id, ;;; Pass agent data
                              pi_val, canvas_width, canvas_height) -> left_agent_inputs;
    get_agent_antenna_reading(agent_x, agent_y, right_antenna_heading,
                              current_agent_pod:antenna_length, current_agent_pod:antenna_tip_radius,
                              current_agent_pod:antenna_angle_offset,
                              all_agents_array, length(all_agents_array), current_agent_pod:id, ;;; Pass agent data
                              pi_val, canvas_width, canvas_height) -> right_agent_inputs;
    ;;; Combine all inputs into a single array for the input layer
    [] -> input_layer_activations;
    0 -> i;
    repeat length(left_food_inputs) times {
        left_food_inputs:i -> val;
        val -> $input_layer_activations;
        i + 1 -> i;
    }
    0 -> i;
    repeat length(left_agent_inputs) times {
        left_agent_inputs:i -> val;
        val -> $input_layer_activations;
        i + 1 -> i;
    }

    0 -> i;
    repeat length(right_food_inputs) times {
        right_food_inputs:i -> val;
        val -> $input_layer_activations;
        i + 1 -> i;
    }
    0 -> i;
    repeat length(right_agent_inputs) times {
        right_agent_inputs:i -> val;
        val -> $input_layer_activations;
        i + 1 -> i;
    }


    ;;; Access weights directly from the agent pod
    current_agent_pod:weights_input_hidden -> agent_weights_ih;
    current_agent_pod:weights_hidden_output -> agent_weights_ho;

    ;;; Calculate hidden layer activations using weights from the pod
    calculate_layer_output(input_layer_activations, agent_weights_ih) -> hidden_layer_activations;

    ;;; Calculate output layer activations using weights from the pod
    calculate_layer_output(hidden_layer_activations, agent_weights_ho) -> output_layer_activations;

    output_layer_activations -> nn_outputs;
}

;;; Function to apply the neural network's outputs to the agent's state
;;; Now takes max_turn_nn_magnitude and max_speed_nn as explicit arguments
fn apply_nn_outputs(current_agent_pod, nn_outputs, max_turn_nn_magnitude, max_speed_nn) -> updated_agent_pod {
    nn_outputs:0 -> left_turn_output;
    nn_outputs:1 -> right_turn_output;
    nn_outputs:2 -> speed_output;
    ;;;1.0 -> speed_output;

    ;;; Calculate turn amount based on difference in left/right turn outputs
    right_turn_output - left_turn_output -> turn_difference;
    turn_difference * max_turn_nn_magnitude -> turn_amount;

    current_agent_pod:heading + turn_amount -> new_heading;

    ;;; Calculate new speed (e.g., speed output maps 0-1 to 0-MAX_SPEED_NN)
    speed_output * max_speed_nn -> new_speed;

    ;;; Ensure speed is not negative
    if (new_speed < 0.0) { 0.0 -> new_speed; }

    ;;; Create a NEW agentPod, copying all members and updating heading and speed
    agentPod(current_agent_pod:x, current_agent_pod:y,
             current_agent_pod:radius, new_speed, ;;; UPDATED: speed
             current_agent_pod:momentum_x, current_agent_pod:momentum_y,
             current_agent_pod:r, current_agent_pod:g, current_agent_pod:b,
             new_heading, ;;; UPDATED: heading
             current_agent_pod:antenna_length, current_agent_pod:antenna_angle_offset,
             current_agent_pod:antenna_tip_radius, current_agent_pod:antenna_r,
             current_agent_pod:antenna_g, current_agent_pod:antenna_b,
             current_agent_pod:flash_timer, current_agent_pod:flash_duration,
             current_agent_pod:flash_r, current_agent_pod:flash_g, current_agent_pod:flash_b,
             current_agent_pod:weights_input_hidden,
             current_agent_pod:weights_hidden_output,
             current_agent_pod:fitness_score,
             current_agent_pod:id, ;;; Pass existing fitness
             current_agent_pod:tail_segment_count, ;;; NEW
             current_agent_pod:tail_segment_scale_factor, ;;; NEW
             current_agent_pod:tail_segment_spacing, ;;; NEW
             current_agent_pod:tail_positions) -> updated_agent_pod; ;;; NEW
}


;;; --- Agent/Food Existing Functions (adjusted for strict parameter passing) ---

;;; UPDATED: Function to create and initialize an agentPod instance, including its NN weights and fitness.
;;; Now takes my_pi and NN constants as explicit arguments.
fn createAgent(initial_x, initial_y, my_pi,
               num_nn_inputs_const,
               num_hidden_neurons_const,
               num_nn_outputs_const,
               index) -> new_agent_pod {
    ;;; Agent base properties
    initial_x -> agent_x_val;
    initial_y -> agent_y_val;
    12 -> agent_radius_val;
    5.0 -> agent_speed_val; ;;; Initial speed, will be determined by NN outputs dynamically
    100 -> agent_r_val;
    100 -> agent_g_val;
    200 -> agent_b_val;

    ;;; Agent eating flash effect properties
    0 -> flash_timer_val;
    30 -> flash_duration_val;
    0 -> flash_r_val;
    255 -> flash_g_val;
    0 -> flash_b_val;

    ;;; Antennae properties
    18 -> antenna_length_val;
    0.4 -> antenna_angle_offset_val;
    2 -> antenna_tip_radius_val;
    100 -> antenna_r_val;
    255 -> antenna_g_val;
    100 -> antenna_b_val;
    random(1.0) * (2 * my_pi) -> agent_heading_val;

    ;;; Initialize neural network weights for this agent
    init2DArray(num_nn_inputs_const + 1, num_hidden_neurons_const) -> weights_ih_val; ;;; +1 for bias row
    init2DArray(num_hidden_neurons_const + 1, num_nn_outputs_const) -> weights_ho_val; ;;; +1 for bias row

    ;;; Tail properties
    5 -> tail_segment_count_val; ;;; Number of segments in the tail
    0.8 -> tail_segment_scale_factor_val; ;;; Each segment is 80% size of the previous
    10.0 -> tail_segment_spacing_val; ;;; NEW: Distance between tail segments

    [] -> initial_tail_positions;

    ;;; Calculate initial offsets based on heading to make tail trail
    cos(agent_heading_val) -> dx_heading;
    sin(agent_heading_val) -> dy_heading;

    0 -> k;
    repeat tail_segment_count_val times {
        ;;; Calculate position for current segment, trailing behind the previous one
        (agent_x_val + (dx_heading * -1 * tail_segment_spacing_val * (k + 1))) -> segment_x;
        (agent_y_val + (dy_heading * -1 * tail_segment_spacing_val * (k + 1))) -> segment_y;

        [^segment_x ^segment_y] -> $initial_tail_positions; ;;; Initialize tail segments
        k + 1 -> k;
    }

    ;;; Create and return the agent pod instance, now including its NN weights and fitness
    agentPod(agent_x_val, agent_y_val, agent_radius_val, agent_speed_val, 0, 0, agent_r_val, agent_g_val, agent_b_val,
             agent_heading_val,
             antenna_length_val, antenna_angle_offset_val, antenna_tip_radius_val, antenna_r_val, antenna_g_val, antenna_b_val,
             flash_timer_val, flash_duration_val, flash_r_val, flash_g_val, flash_b_val,
             weights_ih_val, ;;; Include the newly created weights
             weights_ho_val, ;;; Include the newly created weights
             0, index, ;;; NEW: Initialize fitness_score to 0
             tail_segment_count_val, ;;; NEW
             tail_segment_scale_factor_val, ;;; NEW
             tail_segment_spacing_val, ;;; NEW
             initial_tail_positions) -> new_agent_pod; ;;; NEW
}

fn update_agent_position(all_agents, current_agent_pod) -> all_agents {
    current_agent_pod:x -> old_x;
    current_agent_pod:y -> old_y;
    current_agent_pod:heading -> current_heading;
    current_agent_pod:speed -> current_speed;
    cos(current_heading) -> dx_norm;
    sin(current_heading) -> dy_norm;

    ;;; Retrieve momentum from the previous frame
    current_agent_pod:momentum_x -> prev_momentum_x;
    current_agent_pod:momentum_y -> prev_momentum_y;

    ;;; Apply decay to the previous momentum (e.g., 80% retained, adjust as needed)
    prev_momentum_x * 0.7 -> decayed_momentum_x;
    prev_momentum_y * 0.7 -> decayed_momentum_y;

    ;;; Calculate the movement from the current speed and heading
    (dx_norm * current_speed) -> current_move_x;
    (dy_norm * current_speed) -> current_move_y;

    ;;; Calculate the proposed new position, incorporating both current movement and decayed momentum
    old_x + current_move_x + decayed_momentum_x -> new_x;
    old_y + current_move_y + decayed_momentum_y -> new_y;

    ;;; Determine the momentum for the *next* frame.
    ;;; Initially, it's the sum of current movement and decayed momentum.
    ;;; This allows the "slide" to continue even if the agent's explicit speed drops to 0.
    current_move_x + decayed_momentum_x -> momentum_x_for_next_frame;
    current_move_y + decayed_momentum_y -> momentum_y_for_next_frame;

    ;;; Initialize collision flags/variables
    0 -> collision_occurred;
    -1 -> collided_agent_index; ;;; Store index of collided agent if needed

    0 -> i;
    for agent in all_agents {
        ;;; Skip checking against itself if agents are distinct
        if agent:id /= current_agent_pod:id { ;;; Assuming 'id' is unique for each agent
            agent:x -> checkedX;
            agent:y -> checkedY;
            new_x - checkedX -> dx; ;;; Use new_x, new_y for collision check
            new_y - checkedY -> dy;
            (dx * dx) + (dy * dy) -> dist_sq;
            sqrt(dist_sq) -> dist;
            if dist < (current_agent_pod:radius + agent:radius) { ;;; Check collision based on sum of radii
                old_x -> new_x;
                old_y -> new_y;

                ;;; For the bouncing agent (current_agent_pod):
                ;;; Reverse and/or reduce its momentum to simulate a bounce.
                ;;; The degree of bounce depends on the elasticity.
                ;;; A simple reversal might be:
                momentum_x_for_next_frame * -0.7 -> momentum_x_for_next_frame; ;;; Bounce back with half momentum
                momentum_y_for_next_frame * -0.7 -> momentum_y_for_next_frame;
                (current_move_x + decayed_momentum_x) * 0.7 -> agent:momentum_x;
                (current_move_y + decayed_momentum_y) * 0.7 -> agent:momentum_y;

                agent -> all_agents:i;

                break; ;;; Exit loop on first collision for simplicity
            }
        }
        i + 1 -> i;
    }

    ;;; Now, assign the final momentum values to be stored in the new agentPod
    momentum_x_for_next_frame -> final_momentum_x;
    momentum_y_for_next_frame -> final_momentum_y;

    ;;; Update tail positions - Flexible Trailing for 'free but held together' movement
    current_agent_pod:tail_segment_count -> max_tail_len;
    current_agent_pod:tail_segment_spacing -> spacing;
    current_agent_pod:tail_positions -> current_tail_positions_old;

    [] -> new_tail_positions;

    ;;; The first point the tail follows is the agent's *new* head position (new_x, new_y)
    ;;; This sets the primary anchor for the tail.
    [^new_x ^new_y] -> previous_segment_pos_new; ;;; This will be the reference for the first tail segment


    0 -> k;
    repeat max_tail_len times {
        [] -> current_tail_segment_pos;
        if length(current_tail_positions_old) > k {
            current_tail_positions_old:k -> current_tail_segment_pos;
        } else {
            ;;; If this is a new segment being added to an incomplete tail,
            ;;; initialize it behind the previous segment
            previous_segment_pos_new:0 - (cos(current_heading) * spacing) -> valX;
            previous_segment_pos_new:1 - (sin(current_heading) * spacing) -> valY;
            [^valX ^valY] -> current_tail_segment_pos;
        }

        ;;; Calculate vector from the leader (previous_segment_pos_new) to the current tail segment
        previous_segment_pos_new:0 - current_tail_segment_pos:0 -> dx;
        previous_segment_pos_new:1 - current_tail_segment_pos:1 -> dy;
        (dx * dx) + (dy * dy) -> dist_sq;
        sqrt(dist_sq) -> dist;

        ;;; If the distance is greater than the desired spacing, pull the current segment
        ;;; to be exactly 'spacing' units away from its leader.
        ;;; This ensures segments don't spread too far.
        if dist > spacing {
            (dx / dist) -> nx; ;;; Normalized x component of vector from leader to current segment
            (dy / dist) -> ny; ;;; Normalized y component

            ;;; Move current segment to be 'spacing' units away from leader, along the line from leader to current segment
            (previous_segment_pos_new:0 - (nx * spacing)) -> current_tail_segment_pos:0;
            (previous_segment_pos_new:1 - (ny * spacing)) -> current_tail_segment_pos:1;
        }

        ;;; Add the updated segment position to the new list
        current_tail_segment_pos -> $new_tail_positions;
        
        ;;; This updated segment now becomes the leader for the *next* segment in the chain
        current_tail_segment_pos -> previous_segment_pos_new;
        k + 1 -> k;
    }
    new_tail_positions -> current_tail_positions;


    ;;; Create a NEW agentPod, copying all members and updating x, y, momentum, and tail_positions
    agentPod(new_x, new_y, ;;; UPDATED: x, y
             current_agent_pod:radius, current_agent_pod:speed,
             final_momentum_x, final_momentum_y, ;;; UPDATED: momentum_x, momentum_y
             current_agent_pod:r, current_agent_pod:g, current_agent_pod:b,
             current_agent_pod:heading,
             current_agent_pod:antenna_length, current_agent_pod:antenna_angle_offset,
             current_agent_pod:antenna_tip_radius, current_agent_pod:antenna_r,
             current_agent_pod:antenna_g, current_agent_pod:antenna_b,
             current_agent_pod:flash_timer, current_agent_pod:flash_duration,
             current_agent_pod:flash_r, current_agent_pod:flash_g, current_agent_pod:flash_b,
             current_agent_pod:weights_input_hidden,
             current_agent_pod:weights_hidden_output,
             current_agent_pod:fitness_score,
             current_agent_pod:id,
             current_agent_pod:tail_segment_count, ;;; NEW
             current_agent_pod:tail_segment_scale_factor, ;;; NEW
             current_agent_pod:tail_segment_spacing, ;;; NEW
             current_tail_positions) -> updated_agent_pod; ;;; NEW

    [^all_agents ^updated_agent_pod] -> all_agents;
}

;;; UPDATED: Function to apply toroidal wrap to the agent's position. Returns a NEW agentPod.
fn apply_toroidal_wrap(current_agent_pod, canvas_width, canvas_height) -> updated_agent_pod {
    current_agent_pod:x -> new_x;
    current_agent_pod:y -> new_y;
    if (new_x > canvas_width) { new_x - canvas_width -> new_x; }
    if (new_x < 0.0) { new_x + canvas_width -> new_x; }
    if (new_y > canvas_height) { new_y - canvas_height -> new_y; }
    if (new_y < 0.0) { new_y + canvas_height -> new_y; }

    ;;; Create a NEW agentPod, copying all members and updating x, y, and tail_positions if needed
    ;;; Note: toroidal wrap for tail segments is not explicitly handled here,
    ;;; they will follow the agent's head. If a segment crosses a boundary,
    ;;; it will "pop" to the other side with its parent.
    agentPod(new_x, new_y, ;;; UPDATED: x, y
             current_agent_pod:radius, current_agent_pod:speed,
             current_agent_pod:momentum_x, current_agent_pod:momentum_y,
             current_agent_pod:r, current_agent_pod:g, current_agent_pod:b,
             current_agent_pod:heading,
             current_agent_pod:antenna_length, current_agent_pod:antenna_angle_offset,
             current_agent_pod:antenna_tip_radius, current_agent_pod:antenna_r,
             current_agent_pod:antenna_g, current_agent_pod:antenna_b,
             current_agent_pod:flash_timer, current_agent_pod:flash_duration,
             current_agent_pod:flash_r, current_agent_pod:flash_g, current_agent_pod:flash_b,
             current_agent_pod:weights_input_hidden,
             current_agent_pod:weights_hidden_output,
             current_agent_pod:fitness_score, current_agent_pod:id, ;;; Pass existing fitness
             current_agent_pod:tail_segment_count, ;;; NEW
             current_agent_pod:tail_segment_scale_factor, ;;; NEW
             current_agent_pod:tail_segment_spacing, ;;; NEW
             current_agent_pod:tail_positions) -> updated_agent_pod; ;;; NEW
}

;;; UPDATED: Function to normalize the agent's heading. Returns a NEW agentPod.
fn normalize_agent_heading(current_agent_pod, pi_val) -> updated_agent_pod {
    current_agent_pod:heading -> new_heading;
    if (new_heading < 0.0) { new_heading + (2 * pi_val) -> new_heading; }
    if (new_heading > (2 * pi_val)) { new_heading - (2 * pi_val) -> new_heading; }

    ;;; Create a NEW agentPod, copying all members and updating heading
    agentPod(current_agent_pod:x, current_agent_pod:y,
             current_agent_pod:radius, current_agent_pod:speed,
             current_agent_pod:momentum_x, current_agent_pod:momentum_y,
             current_agent_pod:r, current_agent_pod:g, current_agent_pod:b,
             new_heading, ;;; UPDATED: heading
             current_agent_pod:antenna_length, current_agent_pod:antenna_angle_offset,
             current_agent_pod:antenna_tip_radius, current_agent_pod:antenna_r,
             current_agent_pod:antenna_g, current_agent_pod:antenna_b,
             current_agent_pod:flash_timer, current_agent_pod:flash_duration,
             current_agent_pod:flash_r, current_agent_pod:flash_g, current_agent_pod:flash_b,
             current_agent_pod:weights_input_hidden,
             current_agent_pod:weights_hidden_output,
             current_agent_pod:fitness_score,
             current_agent_pod:id,
             current_agent_pod:tail_segment_count, ;;; NEW
             current_agent_pod:tail_segment_scale_factor, ;;; NEW
             current_agent_pod:tail_segment_spacing, ;;; NEW
             current_agent_pod:tail_positions) -> updated_agent_pod; ;;; NEW
}

;;; Agent drawing function (takes agent_pod by value, does NOT modify it)
fn draw_agent(agent_pod_ref, current_draw_r, current_draw_g, current_draw_b) {
    to_int(agent_pod_ref:x) -> draw_x;
    to_int(agent_pod_ref:y) -> draw_y;

    ;;; Draw Tail Segments (from newest to oldest)
    agent_pod_ref:tail_positions -> tail_positions_array;
    agent_pod_ref:radius -> base_radius;
    agent_pod_ref:tail_segment_scale_factor -> scale_factor;

    0 -> k;
    1.0 -> current_segment_scale; ;;; Initial scale for the first segment calculation

    repeat length(tail_positions_array) times {
        tail_positions_array:k -> segment_pos;
        segment_pos:0 -> segment_x;
        segment_pos:1 -> segment_y;

        ;;; Calculate scaled radius for this segment iteratively
        ;;; The first segment (k=0) is scaled by `scale_factor` once (scale_factor^1).
        ;;; The second segment (k=1) by `scale_factor` twice (scale_factor^2), and so on.
        if (k = 0) {
            scale_factor -> current_segment_scale;
        } else {
            current_segment_scale * scale_factor -> current_segment_scale;
        }

        base_radius * current_segment_scale -> segment_radius;

        ;;; Draw with slightly faded color, or the agent's color
        to_int(current_draw_r * current_segment_scale) -> tail_r;
        to_int(current_draw_g * current_segment_scale) -> tail_g;
        to_int(current_draw_b * current_segment_scale) -> tail_b;

        fillCircle(to_int(segment_x), to_int(segment_y), to_int(segment_radius), tail_r, tail_g, tail_b);
        drawCircle(to_int(segment_x), to_int(segment_y), to_int(segment_radius), 200, 200, tail_b);

        k + 1 -> k;
    }

    fillCircle(draw_x, draw_y, agent_pod_ref:radius, current_draw_r, current_draw_g, current_draw_b);
    drawCircle(draw_x, draw_y, agent_pod_ref:radius, 200, 200, current_draw_b);

    ;;; Antennae 1
    agent_pod_ref:heading - agent_pod_ref:antenna_angle_offset -> antenna1_heading;
    cos(antenna1_heading) -> antenna1_dx;
    sin(antenna1_heading) -> antenna1_dy;
    to_int(agent_pod_ref:x + (antenna1_dx * agent_pod_ref:antenna_length)) -> antenna1_end_x;
    to_int(agent_pod_ref:y + (antenna1_dy * agent_pod_ref:antenna_length)) -> antenna1_end_y;
    drawLine(draw_x, draw_y, antenna1_end_x, antenna1_end_y, agent_pod_ref:antenna_r, agent_pod_ref:antenna_g, agent_pod_ref:antenna_b);
    fillCircle(antenna1_end_x, antenna1_end_y, agent_pod_ref:antenna_tip_radius, agent_pod_ref:antenna_r, agent_pod_ref:antenna_g, agent_pod_ref:antenna_b);

    ;;; Antennae 2
    agent_pod_ref:heading + agent_pod_ref:antenna_angle_offset -> antenna2_heading;
    cos(antenna2_heading) -> antenna2_dx;
    sin(antenna2_heading) -> antenna2_dy;
    to_int(agent_pod_ref:x + (antenna2_dx * agent_pod_ref:antenna_length)) -> antenna2_end_x;
    to_int(agent_pod_ref:y + (antenna2_dy * agent_pod_ref:antenna_length)) -> antenna2_end_y;
    drawLine(draw_x, draw_y, antenna2_end_x, antenna2_end_y, agent_pod_ref:antenna_r, agent_pod_ref:antenna_g, agent_pod_ref:antenna_b);
    fillCircle(antenna2_end_x, antenna2_end_y, agent_pod_ref:antenna_tip_radius, agent_pod_ref:antenna_r, agent_pod_ref:antenna_g, agent_pod_ref:antenna_b);
}

;;; UPDATED: createFoodItems now takes parameters for different food types and colors.
fn createFoodItems(total_count, num_poison_items, maxX, maxY,
                   edible_r, edible_g, edible_b,
                   poison_r, poison_g, poison_b) -> foodItems_array {
    [] -> foodItems_array;
    total_count - num_poison_items -> num_edible_items;

    ;;; Create edible items
    0 -> i_edible;
    repeat num_edible_items times {
        random(maxX) -> x;
        random(maxY) -> y;
        1 -> active_flag;
        foodItem(x, y, active_flag, edible_r, edible_g, edible_b) -> item; ;;; Pass edible color

        while checkOccupied(item, foodItems_array) = true {
            random(maxX) -> x;
            random(maxY) -> y;
            1 -> active_flag;
            foodItem(x, y, active_flag, edible_r, edible_g, edible_b) -> item; ;;; Pass edible color
        }
        item -> $foodItems_array;
        i_edible + 1 -> i_edible;
    } ;;; Create poisonous items
    0 -> i_poison;
    repeat num_poison_items times {
        random(maxX)-> x;
        random(maxY)-> y;
        1 -> active_flag;
        foodItem(x, y, active_flag, poison_r, poison_g, poison_b) -> item; ;;; Pass poisonous color
        while checkOccupied(item, foodItems_array) = true {
            random(maxX)-> x;
            random(maxY)-> y;
            1 -> active_flag;
            foodItem(x, y, active_flag, poison_r, poison_g, poison_b) -> item; ;;; Pass poisonous color
        }
        item -> $foodItems_array;
        i_poison + 1 -> i_poison;
    }
}

;;; UPDATED: draw_food_items now reads color from the food item pod itself.
fn draw_food_items(food_array, count, food_radius) { ;;; Removed food_r, food_g, food_b parameters
    0 -> i;
    repeat count times {
        food_array:i -> current_food_item;
        current_food_item:active -> is_active;
        if (is_active = 1) {
            current_food_item:x -> food_draw_x_float;
            current_food_item:y -> food_draw_y_float;
            current_food_item:r -> item_r; ;;; Read color from pod
            current_food_item:g -> item_g;
            current_food_item:b -> item_b; ;;; Read color from pod
            fillCircle(to_int(food_draw_x_float), to_int(food_draw_y_float), food_radius, item_r, item_g, item_b);
        }
        i + 1 -> i;
    }
}

;;; UPDATED: check_and_consume_food now applies fitness changes and returns updated agentPod
;;; also passes agents_array to check for placement conflicts
fn check_and_consume_food(current_agent_pod, food_array, food_radius, width, height, agents_array) -> result {
    current_agent_pod:fitness_score -> current_fitness;
    0 -> food_eaten_this_frame_flag;
    0 -> poisonous_food_eaten_flag; ;;; NEW: Flag to indicate if poisonous food was eaten

    0 -> i;
    repeat length(food_array) times {
        food_array:i -> current_food_item;
        current_food_item:active -> is_active;
        if (is_active = 1) {
            current_food_item:x -> food_x;
            current_food_item:y -> food_y;
            current_food_item:r -> food_item_r;
            current_food_item:g -> food_item_g;
            current_food_item:b -> food_item_b;

            current_agent_pod:x - food_x -> dx;
            current_agent_pod:y - food_y -> dy;
            (dx * dx) + (dy * dy) -> dist_sq;

            ;;; Calculate combined radii squared for collision detection using current_agent_pod member
            current_agent_pod:radius + food_radius -> combined_radii;
            combined_radii * combined_radii -> combined_radii_sq;
            if (dist_sq <= combined_radii_sq) { ;;;
                current_food_item -> food_array:i; ;;; <<< CRITICAL FIX: Write the modified copy BACK to the array
                1 -> food_eaten_this_frame_flag;

                ;;; Adjust fitness based on food color (Assuming (255,0,0) for poisonous red)
                if (food_item_r = 255 && food_item_g = 0 && food_item_b = 0) {
                    1 -> poisonous_food_eaten_flag; ;;; NEW: Mark that poisonous food was eaten
                    current_fitness - 1 -> current_fitness;
                } else {
                    current_fitness + 1 -> current_fitness;
                }

                ;;; put the food item in a new random position
                ;;; ensure that isn't coccupied by an agent
                random(width) -> current_food_item:x;
                random(height) -> current_food_item:y;
                current_food_item -> food_array:i;
                while checkOccupied(current_food_item, agents_array) = true {
                    random(width) -> current_food_item:x;
                    random(height) -> current_food_item:y;
                    current_food_item -> food_array:i;
                }
                while checkFoodOverlap(i, current_food_item, food_array) = true {
                    random(width) -> current_food_item:x;
                    random(height) -> current_food_item:y;
                    current_food_item -> food_array:i;
                }
            }
        }
        i + 1 -> i;
    }


    ;;; Create a NEW agentPod with updated fitness score
    agentPod(current_agent_pod:x, current_agent_pod:y,
    current_agent_pod:radius, current_agent_pod:speed,
    current_agent_pod:momentum_x, current_agent_pod:momentum_y,
    current_agent_pod:r, current_agent_pod:g, current_agent_pod:b,
    current_agent_pod:heading, current_agent_pod:antenna_length,
    current_agent_pod:antenna_angle_offset, current_agent_pod:antenna_tip_radius,
    current_agent_pod:antenna_r, current_agent_pod:antenna_g, current_agent_pod:antenna_b,
    current_agent_pod:flash_timer, current_agent_pod:flash_duration, current_agent_pod:flash_r,
    current_agent_pod:flash_g, current_agent_pod:flash_b, current_agent_pod:weights_input_hidden,
    current_agent_pod:weights_hidden_output, current_fitness, current_agent_pod:id,
    current_agent_pod:tail_segment_count, current_agent_pod:tail_segment_scale_factor,
    current_agent_pod:tail_segment_spacing, current_agent_pod:tail_positions) -> updated_agent_pod; ;;; Pass existing fitness
    [^updated_agent_pod ^food_eaten_this_frame_flag ^poisonous_food_eaten_flag ^food_array] -> result;
}

;;; NEW: Function to check for collision with infected agents and apply infection
;;; Also deducts fitness from the agent that becomes infected.
fn check_and_apply_infection(current_agent_pod, all_agents_array) -> updated_current_agent_pod {
    current_agent_pod:flash_timer -> current_flash_timer;
    current_agent_pod:flash_r -> current_flash_r;
    current_agent_pod:flash_g -> current_flash_g;
    current_agent_pod:flash_b -> current_flash_b;
    current_agent_pod:fitness_score -> current_fitness;

    0 -> i_other_agent;
    repeat length(all_agents_array) times {
        all_agents_array:i_other_agent -> other_agent_pod;

        ;;; Skip self-collision and if current agent is already infected
        if (other_agent_pod:id /= current_agent_pod:id && current_flash_timer = 0) {
            0 -> is_other_agent_infected;
            0 -> is_current_agent_not_infected;
            if (other_agent_pod:flash_timer > 0 && other_agent_pod:flash_r = 255 && other_agent_pod:flash_g = 0 && other_agent_pod:flash_b = 0) {
                1 -> is_other_agent_infected;
            }
            if (current_agent_pod:flash_timer = 0 || current_agent_pod:flash_r /= 255) { ;;; Not infected, or not red flash
                1 -> is_current_agent_not_infected;
            }
            if (is_other_agent_infected = 1 && is_current_agent_not_infected = 1) {
                ;;; Collision detection logic
                current_agent_pod:x - other_agent_pod:x -> dx;
                current_agent_pod:y - other_agent_pod:y -> dy;
                (dx * dx) + (dy * dy) -> dist_sq;
                (current_agent_pod:radius + other_agent_pod:radius) * 1.2 -> combined_radii;
                combined_radii * combined_radii -> combined_radii_sq;
                if (dist_sq <= combined_radii_sq) {
                    ;;; Current agent becomes infected
                    current_agent_pod:flash_duration -> current_flash_timer;
                    255 -> current_flash_r;
                    0 -> current_flash_g;
                    0 -> current_flash_b;
                    current_fitness - 1 -> current_fitness; ;;; Deduct fitness
                    ;;; Stop checking for other infections if already infected in this step
                    break;
                }
            }
        }
        i_other_agent + 1 -> i_other_agent;
    } ;;; Construct and return the updated agentPod
    agentPod(current_agent_pod:x, current_agent_pod:y, current_agent_pod:radius, current_agent_pod:speed, current_agent_pod:momentum_x, current_agent_pod:momentum_y, current_agent_pod:r, current_agent_pod:g, current_agent_pod:b, current_agent_pod:heading, current_agent_pod:antenna_length, current_agent_pod:antenna_angle_offset, current_agent_pod:antenna_tip_radius, current_agent_pod:antenna_r, current_agent_pod:antenna_g, current_agent_pod:antenna_b, current_flash_timer, current_agent_pod:flash_duration, current_flash_r, current_flash_g, current_flash_b, current_agent_pod:weights_input_hidden, current_agent_pod:weights_hidden_output, current_fitness, current_agent_pod:id, current_agent_pod:tail_segment_count, current_agent_pod:tail_segment_scale_factor, current_agent_pod:tail_segment_spacing, current_agent_pod:tail_positions) -> updated_current_agent_pod;
} ;;; UPDATED: Function to handle the agent's flash effect with different colors based on food type
fn handle_agent_flash_effect(current_agent_pod, was_food_eaten_this_frame, was_poisonous_food_eaten) -> updated_agent_pod {
    current_agent_pod:flash_timer -> new_flash_timer;
    current_agent_pod:flash_r -> new_flash_r;
    current_agent_pod:flash_g -> new_flash_g;
    current_agent_pod:flash_b -> new_flash_b;

    if (new_flash_timer > 0) {
        new_flash_timer - 1 -> new_flash_timer;
        ;;; If timer runs out, reset flash colors to agent's default color
        if (new_flash_timer = 0) {
            current_agent_pod:r -> new_flash_r;
            current_agent_pod:g -> new_flash_g;
            current_agent_pod:b -> new_flash_b;
        }
    } elseif (was_food_eaten_this_frame = 1) {
        current_agent_pod:flash_duration -> new_flash_timer;
        if (was_poisonous_food_eaten = 1) { ;;; Poisonous food: flash red
            255 -> new_flash_r;
            0 -> new_flash_g;
            0 -> new_flash_b;
        } else { ;;; Regular food: flash green
            0 -> new_flash_r;
            255 -> new_flash_g;
            0 -> new_flash_b;
        }
    }

    ;;; Create a NEW agentPod with updated flash properties
    agentPod(current_agent_pod:x, current_agent_pod:y, current_agent_pod:radius, current_agent_pod:speed, current_agent_pod:momentum_x, current_agent_pod:momentum_y, current_agent_pod:r, current_agent_pod:g, current_agent_pod:b, current_agent_pod:heading, current_agent_pod:antenna_length, current_agent_pod:antenna_angle_offset, current_agent_pod:antenna_tip_radius, current_agent_pod:antenna_r, current_agent_pod:antenna_g, current_agent_pod:antenna_b, new_flash_timer, current_agent_pod:flash_duration, new_flash_r, new_flash_g, new_flash_b, current_agent_pod:weights_input_hidden, current_agent_pod:weights_hidden_output, current_agent_pod:fitness_score, current_agent_pod:id, current_agent_pod:tail_segment_count, current_agent_pod:tail_segment_scale_factor, current_agent_pod:tail_segment_spacing, current_agent_pod:tail_positions) -> updated_agent_pod;

}

;;; UPDATED: createAgents now initializes agents with NN weights and fitness.
fn createAgents(num_agents, my_pi_val, num_nn_inputs_const, num_hidden_neurons_const, num_nn_outputs_const) -> agents_array {
    [] -> agents_array;
    0 -> i;
    repeat num_agents times {
        random(1000) -> initial_x;
        random(1000) -> initial_y;
        ;;; Call the UPDATED createAgent function which includes its initialized NN weights and fitness
        createAgent(initial_x, initial_y, my_pi_val, num_nn_inputs_const, num_hidden_neurons_const, num_nn_outputs_const, i) -> new_agent_pod;
        new_agent_pod -> $agents_array; ;;; Append agent pod (with weights) to agents_array
        i + 1 -> i;
    }
} ;;; Function to mutate weights in a 2D array
fn mutate_weights(original_weights, mutation_magnitude) -> mutated_weights_result {
    [] -> mutated_weights_result;
    0 -> r;
    repeat length(original_weights) times {
        original_weights:r -> original_row;
        [] -> new_row;
        0 -> c;
        repeat length(original_row) times {
            original_row:c -> weight_val;
            ;;; Generate a random value between -mutation_magnitude and +mutation_magnitude
            random(1.0) * (2 * mutation_magnitude) - mutation_magnitude -> mutation_amount;
            ;;;prn mutation_amount;
            weight_val + mutation_amount -> mutated_val;
            mutated_val -> $new_row;
            c + 1 -> c;
        }
        new_row -> $mutated_weights_result;
        r + 1 -> r;
    }
}

;;;Function to perform evolutionary selection, reproduction, and mutation
fn perform_evolution(all_agents_array, num_agents, num_fittest_to_select,
    mutation_magnitude, num_nn_inputs_const, num_hidden_neurons_const,
    num_nn_outputs_const, my_pi_val, canvas_width_float, canvas_height_float) -> updated_agents_array {
    ;;; 1. Create a temporary array of [fitness, original_index]
    [] -> fitness_indices;
    0 -> i;
    repeat num_agents times {
        all_agents_array:i -> agent_pod_temp;
        agent_pod_temp:fitness_score -> fitness_score;
        [^fitness_score ^i] -> $fitness_indices; ;;; Store [fitness, original_index]
        i + 1 -> i;
    } ;;; 2. Sort fitness_indices (using simple bubble sort for descending order)
    num_agents -> n_sort;
    1 -> swapped; ;;; Flag to indicate if any swaps occurred in a pass
    while (swapped = 1) {
        0 -> swapped; ;;; Reset swapped flag for this pass
        0 -> i_sort;
        repeat (n_sort - 1) times {
            ;;; Compare adjacent elements
            fitness_indices:i_sort -> current_pair;
            fitness_indices:(i_sort + 1) -> next_pair;

            current_pair:0 -> current_fitness_val;
            next_pair:0 -> next_fitness_val;

            if (current_fitness_val < next_fitness_val) {
                ;;; Swap elements if they are in the wrong order
                next_pair -> fitness_indices:i_sort;
                current_pair -> fitness_indices:(i_sort + 1);
                1 -> swapped;
            }
            i_sort + 1 -> i_sort;
        }
        n_sort - 1 -> n_sort; ;;; Reduce the range for the next pass
    }

    ;;; 3. Create the next generation array
    [] -> next_generation_agents;
    0 -> j_fittest;
    0 -> selected;
    repeat num_fittest_to_select times {
        fitness_indices:j_fittest -> fittest_pair;
        fittest_pair:1 -> original_idx_of_fittest;
        all_agents_array:original_idx_of_fittest -> fittest_agent_pod;
        all_agents_array:selected -> origAgent;
        origAgent:x -> origX;
        origAgent:y -> origY;
        origAgent:heading -> origHeading;
        origAgent:momentum_x -> momentum_x;
        origAgent:momentum_y -> momentum_y;
        ;;; Create a NEW pod for the next generation, resetting fitness to 0
        agentPod(origX, origY, fittest_agent_pod:radius, fittest_agent_pod:speed, momentum_x, momentum_y, fittest_agent_pod:r, fittest_agent_pod:g, fittest_agent_pod:b, origHeading, fittest_agent_pod:antenna_length, fittest_agent_pod:antenna_angle_offset, fittest_agent_pod:antenna_tip_radius, fittest_agent_pod:antenna_r, fittest_agent_pod:antenna_g, fittest_agent_pod:antenna_b, fittest_agent_pod:flash_timer, fittest_agent_pod:flash_duration, fittest_agent_pod:flash_r, fittest_agent_pod:flash_g, fittest_agent_pod:flash_b, fittest_agent_pod:weights_input_hidden, ;;; Keep original weights
                 fittest_agent_pod:weights_hidden_output, ;;; Keep original weights
                 0, selected, ;;; Reset fitness for new generation
                 fittest_agent_pod:tail_segment_count, ;;; Pass tail properties
                 fittest_agent_pod:tail_segment_scale_factor,
                 fittest_agent_pod:tail_segment_spacing,
                 fittest_agent_pod:tail_positions) -> new_fittest_pod; ;;; Pass tail positions
        new_fittest_pod -> $next_generation_agents;
        j_fittest + 1 -> j_fittest;
        selected + 1 -> selected;
    } ;;; Always include a randomly initialized agent for force better
    ;;; exploration of the solution space
    ;;; init2DArray(num_nn_inputs_const + 1, num_hidden_neurons_const) -> weights_ih_val; ;;; +1 for bias row
    ;;; init2DArray(num_hidden_neurons_const + 1, num_nn_outputs_const) -> weights_ho_val; ;;; +1 for bias row
    ;;; all_agents_array:selected -> ag;
    ;;; agentPod(ag:x, ag:y, ag:radius, ag:speed,
    ;;;          ag:momentum_x, ag:momentum_y,
    ;;;          ag:r, ag:g, ag:b, ag:heading,
    ;;;          ag:antenna_length, ag:antenna_angle_offset,
    ;;;          ag:antenna_tip_radius, ag:antenna_r,
    ;;;          ag:antenna_g, ag:antenna_b,
    ;;;          ag:flash_timer, ag:flash_duration,
    ;;;          ag:flash_r, ag:flash_g, ag:flash_b,
    ;;;          weights_ih_val, ;;; Keep original weights
    ;;;          weights_ho_val, ;;; Keep original weights
    ;;;          0, ;;;
    ;;; selected) -> $next_generation_agents;
    ;;;selected + 1 -> selected;
    ;;; 4. Fill the rest of the generation with mutated copies of the fittest agents
    0 -> j_children;
    repeat (num_agents - num_fittest_to_select) times { ;;; Make (num_agents - num_fittest_to_select) children
        j_children % num_fittest_to_select -> parent_index_in_fittest;
        fitness_indices:parent_index_in_fittest -> parent_pair;
        parent_pair:1 -> original_idx_of_parent;
        all_agents_array:original_idx_of_parent -> parent_pod;

        ;;; Mutate parent's weights to create child's weights
        mutate_weights(parent_pod:weights_input_hidden, mutation_magnitude) -> new_ih_weights;
        mutate_weights(parent_pod:weights_hidden_output, mutation_magnitude) -> new_ho_weights;

        ;;; Create new child agent, inheriting properties but with mutated weights
        all_agents_array:selected -> origAgent;
        origAgent:x -> origX;
        origAgent:y -> origY;
        origAgent:heading -> origHeading;
        origAgent:momentum_x -> momentum_x;
        origAgent:momentum_y -> momentum_y;

        agentPod(origX, origY, parent_pod:radius, parent_pod:speed, momentum_x, momentum_y, parent_pod:r, parent_pod:g, parent_pod:b, origHeading, parent_pod:antenna_length, parent_pod:antenna_angle_offset, parent_pod:antenna_tip_radius, parent_pod:antenna_r, parent_pod:antenna_g, parent_pod:antenna_b, 0, ;;; Reset flash timer for new child
                 parent_pod:flash_duration, parent_pod:flash_r, parent_pod:flash_g, parent_pod:flash_b, new_ih_weights, ;;; Mutated weights
                 new_ho_weights, ;;; Mutated weights
                 0, selected, ;;; Reset fitness for new generation
                 parent_pod:tail_segment_count, ;;; Pass tail properties
                 parent_pod:tail_segment_scale_factor,
                 parent_pod:tail_segment_spacing,
                 parent_pod:tail_positions) -> new_child_pod; ;;; Pass tail positions
        new_child_pod -> $next_generation_agents;
        j_children + 1 -> j_children;
        selected + 1 -> selected;
    } ;;; The entire 'all_agents_array' is now replaced with the 'next_generation_agents'
    next_generation_agents -> updated_agents_array;
} ;;; --- Main Program Execution Start ---
start {
    arg(0) -> canvasWidth_int;
    arg(1) -> canvasHeight_int;
    arg(2) -> num_agents_int; ;;; Parameter for number of agents
    init_graphics_canvas(canvasWidth_int, canvasHeight_int, 1, 1); ;;;
    ;;; Constants (local to start block, and thus persist for start's execution)
    3.14159 -> my_pi;
    canvasWidth_int + 0.0 -> canvas_width_float;
    canvasHeight_int + 0.0 -> canvas_height_float;
    ;;; Neural Network Constants (declared locally in start)
    16 -> num_nn_inputs_local;
    16 -> num_hidden_neurons_local;
    3 -> num_nn_outputs_local;
    0.4 -> max_turn_nn_magnitude_local;
    15.0 -> max_speed_nn_local;


    ;;; Evolution Parameters
    100 -> evolution_interval_steps; ;;; N: How many steps before a new generation
    2 -> num_fittest_agents; ;;; F: Number of fittest agents whose NNs are copied
    0.9 -> mutation_magnitude; ;;; Max deviation for weight mutation
    ;;; --- Food Item Properties ---
    40 -> total_food_item_count; ;;; Total number of food items
    0 -> num_poisonous_food_items; ;;; Number of poisonous red items
    5 -> food_radius;
    0 -> edible_food_r;
    255 -> edible_food_g;
    0 -> edible_food_b;
    255 -> poisonous_food_r;
    0 -> poisonous_food_g;
    0 -> poisonous_food_b;
    ;;; --- Simulation Setup ---
    createAgents(num_agents_int, my_pi, num_nn_inputs_local, num_hidden_neurons_local, num_nn_outputs_local) -> all_agents_array; ;;; Initialize agents with NN weights
    createFoodItems(total_food_item_count, num_poisonous_food_items, canvas_width_float, canvas_height_float,
                    edible_food_r, edible_food_g, edible_food_b,
                    poisonous_food_r, poisonous_food_g, poisonous_food_b) -> food_items_array; ;;; Initialize food items
    0 -> current_sim_step;

    while (true) {
        fillRect(0, 0, to_int(canvas_width_float), to_int(canvas_height_float), 0, 0, 0);
        0 -> i;
        0.0 -> average_fitness;
        repeat num_agents_int times {
            all_agents_array:i -> current_agent_pod;
            current_agent_pod:fitness_score + average_fitness -> average_fitness;

            ;;; --- Agent Thinking (Neural Network) ---
            ;;; Agent thinking function now accesses weights directly from the pod
            agent_think(all_agents_array, current_agent_pod, food_items_array, total_food_item_count, food_radius, canvas_width_float, canvas_height_float, my_pi) -> nn_output_vals;
            apply_nn_outputs(current_agent_pod, nn_output_vals, max_turn_nn_magnitude_local, max_speed_nn_local) -> current_agent_pod;

            ;;; DEBUG: Print speed of the first agent to check movement
            ;;; --- Update Current Agent's State (returning new pod, then reassigning to array slot) ---
            update_agent_position(all_agents_array, current_agent_pod) -> updated;

            updated:1 -> current_agent_pod;
            updated:0 -> all_agents_array;
            apply_toroidal_wrap(current_agent_pod, canvas_width_float, canvas_height_float) -> current_agent_pod;
            normalize_agent_heading(current_agent_pod, my_pi) -> current_agent_pod;

            ;;; --- Check for Food Consumption and Handle Agent Flash for current agent ---
            ;;; UPDATED: check_and_consume_food now returns a tuple: [updated_agent_pod, food_eaten_flag, poisonous_food_eaten_flag]
            check_and_consume_food(current_agent_pod, food_items_array, food_radius,
                canvas_width_float, canvas_height_float, all_agents_array) -> food_check_result;
            food_check_result:0 -> current_agent_pod; ;;; Updated agent pod with new fitness
            food_check_result:1 -> food_eaten_this_frame;
            food_check_result:2 -> poisonous_food_eaten_this_frame;
            food_check_result:3 -> food_items_array;

            handle_agent_flash_effect(current_agent_pod, food_eaten_this_frame, poisonous_food_eaten_this_frame) -> current_agent_pod;

            ;;; NEW: Check for infection from other agents (if not already infected)
            check_and_apply_infection(current_agent_pod, all_agents_array) -> current_agent_pod;

            current_agent_pod -> all_agents_array:i;

            ;;; --- Prepare colors for drawing ---
            current_agent_pod:r -> current_agent_draw_r;
            current_agent_pod:g -> current_agent_draw_g;
            current_agent_pod:b -> current_agent_draw_b;

            ;;; If agent is flashing, override draw color
            if (current_agent_pod:flash_timer > 0) {
                current_agent_pod:flash_r -> current_agent_draw_r;
                current_agent_pod:flash_g -> current_agent_draw_g;
                current_agent_pod:flash_b -> current_agent_draw_b;
            } else {
                current_agent_pod:r -> current_agent_draw_r;
                current_agent_pod:g -> current_agent_draw_g;
                current_agent_pod:b -> current_agent_draw_b;
            }

            ;;; --- Draw Current Agent ---
            draw_agent(current_agent_pod, current_agent_draw_r, current_agent_draw_g, current_agent_draw_b);
            i + 1 -> i; ;;; Increment agent loop counter
        }

        ;;; --- Draw Food (outside agent loop, as it's common for all) ---
        ;;; Pass only the food_array, total_food_item_count, and food_radius
        draw_food_items(food_items_array, total_food_item_count, food_radius);

        graphics_process();
        current_sim_step + 1 -> current_sim_step;

        ;;; --- Check for Evolution ---
        if (current_sim_step >= evolution_interval_steps) {
            average_fitness / (num_agents_int + 0.0) -> average_fitness;
            prn average_fitness;
            perform_evolution(all_agents_array, num_agents_int, num_fittest_agents, mutation_magnitude,
                              num_nn_inputs_local, num_hidden_neurons_local, num_nn_outputs_local, my_pi,
                              canvas_width_float, canvas_height_float) -> all_agents_array;
            0 -> current_sim_step; ;;; Reset step counter
            0.0 -> average_fitness; ;;; Reset for next generation
        }
    }
}
